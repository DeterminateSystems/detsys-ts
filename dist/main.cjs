"use strict";var A=Object.create;var u=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var D=Object.getPrototypeOf,W=Object.prototype.hasOwnProperty;var L=(i,t)=>{for(var e in t)u(i,e,{get:t[e],enumerable:!0})},y=(i,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of w(t))!W.call(i,n)&&n!==e&&u(i,n,{get:()=>t[n],enumerable:!(r=B(t,n))||r.enumerable});return i};var a=(i,t,e)=>(e=i!=null?A(D(i)):{},y(t||!i||!i.__esModule?u(e,"default",{value:i,enumerable:!0}):e,i)),K=i=>y(u({},"__esModule",{value:!0}),i);var z={};L(z,{IdsToolbox:()=>v});module.exports=K(z);var g=a(require("@actions/core"),1),S=require("crypto");function U(i){let t={correlation_source:"github-actions",repository:h("GHR",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID"]),workflow:h("GHW",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID","GITHUB_WORKFLOW"]),run:h("GHWR",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID","GITHUB_RUN_ID"]),run_differentiator:h("GHWA",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID","GITHUB_RUN_ID","GITHUB_RUN_NUMBER","GITHUB_RUN_ATTEMPT"]),groups:{ci:"github-actions",project:i,github_organization:h("GHO",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID"])}};return g.debug("Correlation data:"),g.debug(JSON.stringify(t,null,2)),t}function h(i,t){let e=(0,S.createHash)("sha256");for(let r of t){let n=process.env[r];if(n===void 0){g.debug(`Environment variable not set: ${r} -- can't generate the requested identity`);return}else e.update(n),e.update("\0")}return`${i}-${e.digest("hex")}`}var E={name:"detsys-ts",version:"1.0.0",description:"TypeScript goodies for DetSys projects",main:"./dist/main.cjs",types:"./dist/main.d.cts",type:"module",scripts:{build:"tsup","check-fmt":"prettier --check .",format:"prettier --write .",lint:"eslint src/**/*.ts",prebuild:"cp package.json ./src/package.json",all:"pnpm run check-fmt && pnpm run lint && pnpm run prebuild && pnpm run build"},repository:{type:"git",url:"git+https://github.com/DeterminateSystems/detsys-ts.git"},keywords:[],author:"",license:"ISC",bugs:{url:"https://github.com/DeterminateSystems/detsys-ts/issues"},homepage:"https://github.com/DeterminateSystems/detsys-ts#readme",dependencies:{"@actions/cache":"^3.2.4","@actions/core":"^1.10.0","@actions/exec":"^1.1.1","@actions/github":"^5.1.1","fetch-retry":"^5.0.6",got:"^14.2.1","string-argv":"^0.3.2",uuid:"^9.0.1"},devDependencies:{"@trivago/prettier-plugin-sort-imports":"^4.3.0","@types/node":"^18.19.30","@types/uuid":"^9.0.8","@typescript-eslint/eslint-plugin":"^7.2.0",eslint:"^8.57.0","eslint-import-resolver-typescript":"^3.6.1","eslint-plugin-github":"^4.3.6","eslint-plugin-import":"^2.29.1","eslint-plugin-prettier":"^5.0.0-alpha.1",prettier:"^3.0.0",tsup:"^8.0.2",typescript:"^5.1.6"}};var l=a(require("@actions/core"),1);function I(){let i=process.env.RUNNER_ARCH,t=process.env.RUNNER_OS;if(i&&t)return`${i}-${t}`;throw l.error(`Can't identify the platform: RUNNER_ARCH or RUNNER_OS undefined (${i}-${t})`),new Error("RUNNER_ARCH and/or RUNNER_OS is not defined")}function T(i){let e=new Map([["X64-macOS","x86_64-darwin"],["ARM64-macOS","aarch64-darwin"],["X64-Linux","x86_64-linux"],["ARM64-Linux","aarch64-linux"]]).get(i);if(e)return e;throw l.error(`ArchOs (${i}) doesn't map to a supported Nix platform.`),new Error(`Cannot convert ArchOs (${i}) to a supported Nix platform.`)}var p=a(require("@actions/core"),1);function P(i){let t=e=>{let r=C(`source-${e}`);if(!i)return r;let n=C(`${i}-${e}`);return r&&n?(p.warning(`The supported option source-${e} and the legacy option ${i}-${e} are both set. Preferring source-${e}. Please stop setting ${i}-${e}.`),r):n?(p.warning(`The legacy option ${i}-${e} is set. Please migrate to source-${e}.`),n):r};return{path:t("path"),url:t("url"),tag:t("tag"),pr:t("pr"),branch:t("branch"),revision:t("revision")}}function C(i){let t=p.getInput(i);if(t!=="")return t}var m=a(require("@actions/cache"),1),s=a(require("@actions/core"),1),O=a(require("got"),1),H=require("crypto"),N=require("fs"),o=a(require("fs/promises"),1),b=require("os"),G=a(require("path"),1),$=require("stream/promises"),x=require("uuid"),_="https://install.determinate.systems",f=process.env.IDS_HOST??_,R=O.default.extend({retry:{limit:3,methods:["GET","HEAD"]},hooks:{beforeRetry:[(i,t)=>{s.info(`Retrying after error ${i.code}, retry #: ${t}`)}]}}),v=class{constructor(t){this.actionOptions=j(t),this.events=[],this.client=O.default.extend({retry:{limit:3,methods:["GET","HEAD"]},hooks:{beforeRetry:[(r,n)=>{s.info(`Retrying after error ${r.code}, retry #: ${n}`)}]}}),this.facts={$lib:"idslib",$lib_version:E.version,project:this.actionOptions.name,ids_project:this.actionOptions.idsProjectName};let e=[["github_action_ref","GITHUB_ACTION_REF"],["github_action_repository","GITHUB_ACTION_REPOSITORY"],["github_event_name","GITHUB_EVENT_NAME"],["$os","RUNNER_OS"],["arch","RUNNER_ARCH"]];for(let[r,n]of e){let c=process.env[n];c&&(this.facts[r]=c)}if(this.identity=U(this.actionOptions.name),this.archOs=I(),this.nixSystem=T(this.archOs),this.facts.arch_os=this.archOs,this.facts.nix_system=this.nixSystem,s.getState("idstoolbox_execution_phase")===""?(s.saveState("idstoolbox_execution_phase","post"),this.executionPhase="main"):this.executionPhase="post",this.facts.execution_phase=this.executionPhase,this.actionOptions.fetchStyle==="gh-env-style")this.architectureFetchSuffix=this.archOs;else if(this.actionOptions.fetchStyle==="nix-style")this.architectureFetchSuffix=this.nixSystem;else if(this.actionOptions.fetchStyle==="universal")this.architectureFetchSuffix="universal";else throw new Error(`fetchStyle ${this.actionOptions.fetchStyle} is not a valid style`);this.sourceParameters=P(this.actionOptions.legacySourcePrefix),this.recordEvent(`begin_${this.executionPhase}`)}addFact(t,e){this.facts[t]=e}getDiagnosticsUrl(){return this.actionOptions.diagnosticsUrl}getUniqueId(){return this.identity.run_differentiator||process.env.RUNNER_TRACKING_ID||(0,H.randomUUID)()}getCorrelationHashes(){return this.identity}recordEvent(t,e={}){this.events.push({event_name:`${this.actionOptions.eventPrefix}${t}`,context:e,correlation:this.identity,facts:this.facts,timestamp:new Date})}async fetch(){s.info(`Fetching from ${this.getUrl()}`);let t=this.getUrl();t.searchParams.set("ci","github"),t.searchParams.set("correlation",JSON.stringify(this.identity));let e=await R.head(t);if(e.headers.etag){let c=e.headers.etag;s.debug(`Checking the tool cache for ${this.getUrl()} at ${c}`);let d=await this.getCachedVersion(c);if(d)return this.facts.artifact_fetched_from_cache=!0,s.debug("Tool cache hit."),d}this.facts.artifact_fetched_from_cache=!1,s.debug(`No match from the cache, re-fetching from the redirect: ${e.url}`);let r=this.getTemporaryName(),n=R.stream(e.url);if(await(0,$.pipeline)(n,(0,N.createWriteStream)(r,{encoding:"binary",mode:493})),n.response?.headers.etag){let c=n.response.headers.etag;try{await this.saveCachedVersion(c,r)}catch(d){s.debug(`Error caching the artifact: ${d}`)}}return r}async fetchExecutable(){let t=await this.fetch();return await(0,o.chmod)(t,o.default.constants.S_IXUSR|o.default.constants.S_IXGRP),t}async complete(){this.recordEvent(`complete_${this.executionPhase}`),await this.submitEvents()}getUrl(){let t=this.sourceParameters;if(t.url)return new URL(t.url);let e=new URL(f);return e.pathname+=this.actionOptions.idsProjectName,t.tag?e.pathname+=`/tag/${t.tag}`:t.pr?e.pathname+=`/pr/${t.pr}`:t.branch?e.pathname+=`/branch/${t.branch}`:t.revision?e.pathname+=`/rev/${t.revision}`:e.pathname+="/stable",e.pathname+=`/${this.architectureFetchSuffix}`,e}cacheKey(t){let e=t.replace(/[^a-zA-Z0-9-+.]/g,"");return`determinatesystem-${this.actionOptions.name}-${this.architectureFetchSuffix}-${e}`}async getCachedVersion(t){let e=process.cwd();try{let r=this.getTemporaryName();if(await(0,o.mkdir)(r),process.chdir(r),process.env.GITHUB_WORKSPACE_BACKUP=process.env.GITHUB_WORKSPACE,delete process.env.GITHUB_WORKSPACE,await m.restoreCache([this.actionOptions.name],this.cacheKey(t),[],void 0,!0))return this.recordEvent("artifact_cache_hit"),`${r}/${this.actionOptions.name}`;this.recordEvent("artifact_cache_miss");return}finally{process.env.GITHUB_WORKSPACE=process.env.GITHUB_WORKSPACE_BACKUP,delete process.env.GITHUB_WORKSPACE_BACKUP,process.chdir(e)}}async saveCachedVersion(t,e){let r=process.cwd();try{let n=this.getTemporaryName();await(0,o.mkdir)(n),process.chdir(n),await(0,o.copyFile)(e,`${n}/${this.actionOptions.name}`),process.env.GITHUB_WORKSPACE_BACKUP=process.env.GITHUB_WORKSPACE,delete process.env.GITHUB_WORKSPACE,await m.saveCache([this.actionOptions.name],this.cacheKey(t),void 0,!0),this.recordEvent("artifact_cache_hit")}finally{process.env.GITHUB_WORKSPACE=process.env.GITHUB_WORKSPACE_BACKUP,delete process.env.GITHUB_WORKSPACE_BACKUP,process.chdir(r)}}async submitEvents(){if(!this.actionOptions.diagnosticsUrl){s.debug("Diagnostics are disabled. Not sending the following events:"),s.debug(JSON.stringify(this.events,void 0,2));return}let t={type:"eventlog",sent_at:new Date,events:this.events};try{await R.post(this.actionOptions.diagnosticsUrl,{json:t})}catch(e){s.debug(`Error submitting diagnostics event: ${e}`)}this.events=[]}getTemporaryName(){let t=process.env.RUNNER_TEMP||(0,b.tmpdir)();return G.join(t,`${this.actionOptions.name}-${(0,x.v4)()}`)}};function j(i){let t=i.idsProjectName??i.name,e={name:i.name,idsProjectName:t,eventPrefix:i.eventPrefix||"action:",fetchStyle:i.fetchStyle,legacySourcePrefix:i.legacySourcePrefix,diagnosticsUrl:V(t,i.diagnosticsUrl)};return s.debug("idslib options:"),s.debug(JSON.stringify(e,void 0,2)),e}function V(i,t){if(t!==null){if(t!==void 0)return t;{let e=process.env["INPUT_DIAGNOSTIC-ENDPOINT"];if(e==="")return;if(e!==void 0)try{return M(new URL(e))}catch(r){s.info(`User-provided diagnostic endpoint ignored: not a valid URL: ${r}`)}}try{let e=new URL(f);return e.pathname+=i,e.pathname+="/diagnostics",e}catch(e){s.info(`Generated diagnostic endpoint ignored: not a valid URL: ${e}`)}}}function M(i){if(_===f)return i;try{let t=new URL(_),e=new URL(f);return i.origin!==t.origin||(i.protocol=e.protocol,i.host=e.host,i.username=e.username,i.password=e.password),i}catch(t){s.info(`Default or overridden IDS host isn't a valid URL: ${t}`)}return i}0&&(module.exports={IdsToolbox});
//# sourceMappingURL=main.cjs.map