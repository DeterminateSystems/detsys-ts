"use strict";var G=Object.create;var u=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var B=Object.getPrototypeOf,A=Object.prototype.hasOwnProperty;var w=(r,e)=>{for(var t in e)u(r,t,{get:e[t],enumerable:!0})},R=(r,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of x(e))!A.call(r,n)&&n!==t&&u(r,n,{get:()=>e[n],enumerable:!(i=$(e,n))||i.enumerable});return r};var o=(r,e,t)=>(t=r!=null?G(B(r)):{},R(e||!r||!r.__esModule?u(t,"default",{value:r,enumerable:!0}):t,r)),b=r=>R(u({},"__esModule",{value:!0}),r);var Y={};w(Y,{IdsToolbox:()=>m});module.exports=b(Y);var f=o(require("@actions/core"),1),_=require("crypto");function O(r){let e={correlation_source:"github-actions",repository:a("GHR",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID"]),workflow:a("GHW",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID","GITHUB_WORKFLOW"]),run:a("GHWR",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID","GITHUB_RUN_ID"]),run_differentiator:a("GHWA",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID","GITHUB_REPOSITORY","GITHUB_REPOSITORY_ID","GITHUB_RUN_ID","GITHUB_RUN_NUMBER","GITHUB_RUN_ATTEMPT"]),groups:{ci:"github-actions",project:r,github_organization:a("GHO",["GITHUB_SERVER_URL","GITHUB_REPOSITORY_OWNER","GITHUB_REPOSITORY_OWNER_ID"])}};return f.debug("Correlation data:"),f.debug(JSON.stringify(e,null,2)),e}function a(r,e){let t=(0,_.createHash)("sha256");for(let i of e){let n=process.env[i];if(n===void 0){f.debug(`Environment variable not set: ${i} -- can't generate the requested identity`);return}else t.update(n),t.update("\0")}return`${r}-${t.digest("hex")}`}var l=o(require("@actions/core"),1);function v(){let r=process.env.RUNNER_ARCH,e=process.env.RUNNER_OS;if(r&&e)return`${r}-${e}`;throw l.error(`Can't identify the platform: RUNNER_ARCH or RUNNER_OS undefined (${r}-${e})`),new Error("RUNNER_ARCH and/or RUNNER_OS is not defined")}function U(r){let t=new Map([["X64-macOS","x86_64-darwin"],["ARM64-macOS","aarch64-darwin"],["X64-Linux","x86_64-linux"],["ARM64-Linux","aarch64-linux"]]).get(r);if(t)return t;throw l.error(`ArchOs (${r}) doesn't map to a supported Nix platform.`),new Error(`Cannot convert ArchOs (${r}) to a supported Nix platform.`)}var c=o(require("@actions/core"),1);function E(r){let e=t=>{let i=S(`source-${t}`);if(!r)return i;let n=S(`${r}-${t}`);return i&&n?(c.warning(`The supported option source-${t} and the legacy option ${r}-${t} are both set. Preferring source-${t}. Please stop setting ${r}-${t}.`),i):n?(c.warning(`The legacy option ${r}-${t} is set. Please migrate to source-${t}.`),n):i};return{path:e("path"),url:e("url"),tag:e("tag"),pr:e("pr"),branch:e("branch"),revision:e("revision")}}function S(r){let e=c.getInput(r);if(e!=="")return e}var g=o(require("@actions/cache"),1),s=o(require("@actions/core"),1),y=o(require("got"),1),I=require("fs"),h=require("fs/promises"),P=require("os"),T=o(require("path"),1),C=require("stream/promises"),H=require("uuid"),N=process.env.IDS_HOST??"https://install.determinate.systems",m=class{constructor(e){if(this.actionOptions=K(e),this.facts={},this.events=[],this.client=y.default.extend({retry:{limit:3,methods:["GET","HEAD"]},hooks:{beforeRetry:[(t,i)=>{s.info(`Retrying after error ${t.code}, retry #: ${i}`)}]}}),this.identity=O(this.actionOptions.name),this.archOs=v(),this.nixSystem=U(this.archOs),s.getState("idstoolbox_execution_phase")===""?(s.saveState("idstoolbox_execution_phase","post"),this.executionPhase="action"):this.executionPhase="post",this.facts.execution_phase=this.executionPhase,this.actionOptions.fetchStyle==="gh-env-style")this.architectureFetchSuffix=this.archOs;else if(this.actionOptions.fetchStyle==="nix-style")this.architectureFetchSuffix=this.nixSystem;else if(this.actionOptions.fetchStyle==="universal")this.architectureFetchSuffix="universal";else throw new Error(`fetchStyle ${this.actionOptions.fetchStyle} is not a valid style`);this.sourceParameters=E(this.actionOptions.legacySourcePrefix),this.recordEvent(`start_${this.executionPhase}`)}recordEvent(e,t={}){this.events.push({event_name:`${this.actionOptions.eventPrefix}${e}`,context:t,correlation:this.identity,facts:this.facts,timestamp:new Date})}async fetch(){s.info(`Fetching from ${this.getUrl()}`);let e=this.getUrl();e.searchParams.set("ci","github"),e.searchParams.set("correlation",JSON.stringify(this.identity));let t=await this.client.head(e);if(t.headers.etag){let p=t.headers.etag;s.debug(`Checking the tool cache for ${this.getUrl()} at ${p}`);let d=await this.getCachedVersion(p);if(d)return this.facts.artifact_fetched_from_cache=!0,s.debug("Tool cache hit."),d}this.facts.artifact_fetched_from_cache=!1,s.debug(`No match from the cache, re-fetching from the redirect: ${t.url}`);let i=this.getTemporaryName(),n=this.client.stream(t.url);if(await(0,C.pipeline)(n,(0,I.createWriteStream)(i,{encoding:"binary",mode:493})),n.response?.headers.etag){let p=n.response.headers.etag;try{await this.saveCachedVersion(p,i)}catch(d){s.debug(`Error caching the artifact: ${d}`)}}return i}async complete(){this.recordEvent(`complete_${this.executionPhase}`),await this.submitEvents()}getUrl(){let e=this.sourceParameters;if(e.url)return new URL(e.url);let t=new URL(N);return t.pathname+=this.actionOptions.idsProjectName,e.tag?t.pathname+=`/tag/${e.tag}`:e.pr?t.pathname+=`/pr/${e.pr}`:e.branch?t.pathname+=`/branch/${e.branch}`:e.revision?t.pathname+=`/rev/${e.revision}`:t.pathname+="/stable",t.pathname+=`/${this.architectureFetchSuffix}`,t}cacheKey(e){let t=e.replace(/[^a-zA-Z0-9-+.]/g,"");return`determinatesystem-${this.actionOptions.name}-${this.architectureFetchSuffix}-${t}`}async getCachedVersion(e){let t=process.cwd();try{let i=this.getTemporaryName();if(await(0,h.mkdir)(i),process.chdir(i),process.env.GITHUB_WORKSPACE_BACKUP=process.env.GITHUB_WORKSPACE,delete process.env.GITHUB_WORKSPACE,await g.restoreCache([this.actionOptions.name],this.cacheKey(e),[],void 0,!0))return this.recordEvent("artifact_cache_hit"),`${i}/${this.actionOptions.name}`;this.recordEvent("artifact_cache_miss");return}finally{process.env.GITHUB_WORKSPACE=process.env.GITHUB_WORKSPACE_BACKUP,delete process.env.GITHUB_WORKSPACE_BACKUP,process.chdir(t)}}async saveCachedVersion(e,t){let i=process.cwd();try{let n=this.getTemporaryName();await(0,h.mkdir)(n),process.chdir(n),await(0,h.copyFile)(t,`${n}/${this.actionOptions.name}`),process.env.GITHUB_WORKSPACE_BACKUP=process.env.GITHUB_WORKSPACE,delete process.env.GITHUB_WORKSPACE,await g.saveCache([this.actionOptions.name],this.cacheKey(e),void 0,!0),this.recordEvent("artifact_cache_hit")}finally{process.env.GITHUB_WORKSPACE=process.env.GITHUB_WORKSPACE_BACKUP,delete process.env.GITHUB_WORKSPACE_BACKUP,process.chdir(i)}}async submitEvents(){if(!this.actionOptions.diagnosticsUrl){s.debug("Diagnostics are disabled. Not sending the following events:"),s.debug(JSON.stringify(this.events,void 0,2));return}try{await this.client.post(this.actionOptions.diagnosticsUrl,{json:{type:"eventlog",sent_at:new Date,events:this.events}})}catch(e){s.debug(`Error submitting diagnostics event: ${e}`)}this.events=[]}getTemporaryName(){let e=process.env.RUNNER_TEMP||(0,P.tmpdir)();return T.join(e,`${this.actionOptions.name}-${(0,H.v4)()}`)}};function K(r){let e=r.idsProjectName??r.name;return{name:r.name,idsProjectName:e,eventPrefix:r.eventPrefix||`action:${r.name}:`,fetchStyle:r.fetchStyle,legacySourcePrefix:r.legacySourcePrefix,diagnosticsUrl:L(e,r.diagnosticsUrl)}}function L(r,e){if(e!==null){if(e!==void 0)return e;{let t=process.env.INPUT_DIAGNOSTIC_ENDPOINT;if(t==="")return;if(t!==void 0)try{return new URL(t)}catch(i){s.info(`User-provided diagnostic endpoint ignored: not a valid URL: ${i}`)}}try{let t=new URL(N);return t.pathname+=r,t.pathname+="/diagnostics",t}catch(t){s.info(`Generated diagnostic endpoint ignored: not a valid URL: ${t}`)}}}0&&(module.exports={IdsToolbox});
//# sourceMappingURL=main.cjs.map